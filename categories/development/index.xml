<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>development on André Bazaglia</title>
    <link>https://bazaglia.com/categories/development/</link>
    <description>Recent content in development on André Bazaglia</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sun, 29 Sep 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://bazaglia.com/categories/development/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Clean architecture with TypeScript: DDD, Onion</title>
      <link>https://bazaglia.com/clean-architecture-with-typescript-ddd-onion/</link>
      <pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bazaglia.com/clean-architecture-with-typescript-ddd-onion/</guid>
      <description>Introduction Writing maintainable code should be taken into consideration as it is as important as scalability, resilience, and other infrastructure aspects when you have your application running in production. There are many architectural principles that a maintainable code implements, and the source code for the project structure that we will go through in this article is available in a Github repository at the end of the post.
The focus of this article is not to cover big topics like DDD and Onion Architecture, but to provide an example of how to implement these two patterns in TypeScript.</description>
    </item>
    
    <item>
      <title>List all files containing a string from Terminal</title>
      <link>https://bazaglia.com/list-all-files-containing-a-string-from-terminal/</link>
      <pubDate>Sat, 05 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bazaglia.com/list-all-files-containing-a-string-from-terminal/</guid>
      <description>Sometimes you may find it very useful to find any files containing a string. While most code editors provide this features when you add a folder as a project, you may be just navigating inside your terminal and need a quicker way to achieve that.
The grep is a very powerful command for search patterns, and is available by default in most of Linux distro&amp;rsquo;s and also Mac.
You may try, for example:</description>
    </item>
    
    <item>
      <title>How to import compressed MySQL file on the command line</title>
      <link>https://bazaglia.com/how-to-import-compressed-mysql-file-on-the-command-line/</link>
      <pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://bazaglia.com/how-to-import-compressed-mysql-file-on-the-command-line/</guid>
      <description>zcat restores compressed files to their original forms, while pv monitor the progress of data through a pipe (in other words, allows users to view a progress of a data through a pipeline).
Combining these two commands we can import a compressed MySQL database while vieweing the progress.
The final command is:
zcat database.sql.gz | pv -cN zcat | mysql -u user -p dbname  In case it fails on your operational system, here&amp;rsquo;s a variation:</description>
    </item>
    
  </channel>
</rss>